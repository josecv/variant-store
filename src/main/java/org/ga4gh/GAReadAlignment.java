/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */
package org.ga4gh;  
@SuppressWarnings("all")
/** Each read alignment describes a linear alignment with additional information
about the fragment and the read. A read alignment object is equivalent to a
line in a SAM file. */
@org.apache.avro.specific.AvroGenerated
public class GAReadAlignment extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
  public static final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse("{\"type\":\"record\",\"name\":\"GAReadAlignment\",\"namespace\":\"org.ga4gh\",\"doc\":\"Each read alignment describes a linear alignment with additional information\\nabout the fragment and the read. A read alignment object is equivalent to a\\nline in a SAM file.\",\"fields\":[{\"name\":\"id\",\"type\":[\"null\",\"string\"],\"doc\":\"The read alignment ID. This ID is unique within the read group this\\n  alignment belongs to. This field may not be provided by all backends.\\n  Its intended use is to make caching and UI display easier for\\n  genome browsers and other light weight clients.\"},{\"name\":\"readGroupId\",\"type\":\"string\",\"doc\":\"The ID of the read group this read belongs to.\\n  (Every read must belong to exactly one read group.)\"},{\"name\":\"fragmentName\",\"type\":\"string\",\"doc\":\"The fragment name. Equivalent to QNAME (query template name) in SAM.\"},{\"name\":\"properPlacement\",\"type\":[\"null\",\"boolean\"],\"doc\":\"The orientation and the distance between reads from the fragment are\\n  consistent with the sequencing protocol (extension to SAM flag 0x2)\",\"default\":false},{\"name\":\"duplicateFragment\",\"type\":[\"null\",\"boolean\"],\"doc\":\"The fragment is a PCR or optical duplicate (SAM flag 0x400)\",\"default\":false},{\"name\":\"numberReads\",\"type\":[\"null\",\"int\"],\"doc\":\"The number of reads in the fragment (extension to SAM flag 0x1)\",\"default\":null},{\"name\":\"fragmentLength\",\"type\":[\"null\",\"int\"],\"doc\":\"The observed length of the fragment, equivalent to TLEN in SAM.\",\"default\":null},{\"name\":\"readNumber\",\"type\":[\"null\",\"int\"],\"doc\":\"The read number in sequencing. 0-based and less than numberReads. This field\\n  replaces SAM flag 0x40 and 0x80.\",\"default\":null},{\"name\":\"failedVendorQualityChecks\",\"type\":[\"null\",\"boolean\"],\"doc\":\"SAM flag 0x200\",\"default\":false},{\"name\":\"alignment\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"GALinearAlignment\",\"doc\":\"A linear alignment can be represented by one CIGAR string.\",\"fields\":[{\"name\":\"position\",\"type\":{\"type\":\"record\",\"name\":\"GAPosition\",\"doc\":\"An abstraction for referring to a genomic position, in relation to some\\nalready known reference. For now, represents a genomic position as a reference\\nname, a base number on that reference (0-based), and a flag to say if it's the\\nforward or reverse strand that we're talking about.\",\"fields\":[{\"name\":\"referenceName\",\"type\":\"string\",\"doc\":\"The name of the reference (or, more technically, the scaffold) in whatever\\n  reference set is being used. Does not generally include a \\\"chr\\\" prefix, so for\\n  example \\\"X\\\" would be used for the X chromosome.\"},{\"name\":\"position\",\"type\":\"long\",\"doc\":\"The 0-based offset from the start of the forward strand for that reference.\\n  Genomic positions are non-negative integers less than reference length.\"},{\"name\":\"reverseStrand\",\"type\":\"boolean\",\"doc\":\"A flag to indicate if we are on the forward strand (`false`) or reverse\\n  strand (`true`).\"}]},\"doc\":\"The position of this alignment.\"},{\"name\":\"mappingQuality\",\"type\":[\"null\",\"int\"],\"doc\":\"The mapping quality of this alignment. Represents how likely\\n  the read maps to this position as opposed to other locations.\",\"default\":null},{\"name\":\"cigar\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"GACigarUnit\",\"doc\":\"A structure for an instance of a CIGAR operation.\",\"fields\":[{\"name\":\"operation\",\"type\":{\"type\":\"enum\",\"name\":\"GACigarOperation\",\"doc\":\"An enum for the different types of CIGAR alignment operations that exist.\\nUsed wherever CIGAR alignments are used. The different enumerated values\\nhave the following usage:\\n\\n* `ALIGNMENT_MATCH`: An alignment match indicates that a sequence can be\\n  aligned to the reference without evidence of an INDEL. Unlike the\\n  `SEQUENCE_MATCH` and `SEQUENCE_MISMATCH` operators, the `ALIGNMENT_MATCH`\\n  operator does not indicate whether the reference and read sequences are an\\n  exact match. This operator is equivalent to SAM's `M`.\\n* `INSERT`: The insert operator indicates that the read contains evidence of\\n  bases being inserted into the reference. This operator is equivalent to\\n  SAM's `I`.\\n* `DELETE`: The delete operator indicates that the read contains evidence of\\n  bases being deleted from the reference. This operator is equivalent to\\n  SAM's `D`.\\n* `SKIP`: The skip operator indicates that this read skips a long segment of\\n  the reference, but the bases have not been deleted. This operator is\\n  commonly used when working with RNA-seq data, where reads may skip long\\n  segments of the reference between exons. This operator is equivalent to\\n  SAM's 'N'.\\n* `CLIP_SOFT`: The soft clip operator indicates that bases at the start/end\\n  of a read have not been considered during alignment. This may occur if the\\n  majority of a read maps, except for low quality bases at the start/end of\\n  a read. This operator is equivalent to SAM's 'S'. Bases that are soft clipped\\n  will still be stored in the read.\\n* `CLIP_HARD`: The hard clip operator indicates that bases at the start/end of\\n  a read have been omitted from this alignment. This may occur if this linear\\n  alignment is part of a chimeric alignment, or if the read has been trimmed\\n  (e.g., during error correction, or to trim poly-A tails for RNA-seq). This\\n  operator is equivalent to SAM's 'H'.\\n* `PAD`: The pad operator indicates that there is padding in an alignment.\\n  This operator is equivalent to SAM's 'P'.\\n* `SEQUENCE_MATCH`: This operator indicates that this portion of the aligned\\n  sequence exactly matches the reference (e.g., all bases are equal to the\\n  reference bases). This operator is equivalent to SAM's '='.\\n* `SEQUENCE_MISMATCH`: This operator indicates that this portion of the\\n  aligned sequence is an alignment match to the reference, but a sequence\\n  mismatch (e.g., the bases are not equal to the reference). This can\\n  indicate a SNP or a read error. This operator is equivalent to SAM's 'X'.\",\"symbols\":[\"ALIGNMENT_MATCH\",\"INSERT\",\"DELETE\",\"SKIP\",\"CLIP_SOFT\",\"CLIP_HARD\",\"PAD\",\"SEQUENCE_MATCH\",\"SEQUENCE_MISMATCH\"]},\"doc\":\"The operation type.\"},{\"name\":\"operationLength\",\"type\":\"long\",\"doc\":\"The number of bases that the operation runs for.\"},{\"name\":\"referenceSequence\",\"type\":[\"null\",\"string\"],\"doc\":\"`referenceSequence` is only used at mismatches (`SEQUENCE_MISMATCH`)\\n  and deletions (`DELETE`). Filling this field replaces the MD tag.\\n  If the relevant information is not available, leave this field as `null`.\",\"default\":null}]}},\"doc\":\"Represents the local alignment of this sequence (alignment matches, indels, etc)\\n  versus the reference.\",\"default\":[]}]}],\"doc\":\"The linear alignment for this alignment record. This field will be\\n  null if the read is unmapped.\",\"default\":null},{\"name\":\"secondaryAlignment\",\"type\":[\"null\",\"boolean\"],\"doc\":\"Whether this alignment is secondary. Equivalent to SAM flag 0x100.\\n  A secondary alignment represents an alternative to the primary alignment\\n  for this read. Aligners may return secondary alignments if a read can map\\n  ambiguously to multiple coordinates in the genome.\\n\\n  By convention, each read has one and only one alignment where both\\n  secondaryAlignment and supplementaryAlignment are false.\",\"default\":false},{\"name\":\"supplementaryAlignment\",\"type\":[\"null\",\"boolean\"],\"doc\":\"Whether this alignment is supplementary. Equivalent to SAM flag 0x800.\\n  Supplementary alignments are used in the representation of a chimeric\\n  alignment. In a chimeric alignment, a read is split into multiple\\n  linear alignments that map to different reference contigs. The first\\n  linear alignment in the read will be designated as the representative alignment;\\n  the remaining linear alignments will be designated as supplementary alignments.\\n  These alignments may have different mapping quality scores.\\n\\n  In each linear alignment in a chimeric alignment, the read will be hard clipped.\\n  The `alignedSequence` and `alignedQuality` fields in the alignment record will\\n  only represent the bases for its respective linear alignment.\",\"default\":false},{\"name\":\"alignedSequence\",\"type\":[\"null\",\"string\"],\"doc\":\"The bases of the read sequence contained in this alignment record.\\n  `alignedSequence` and `alignedQuality` may be shorter than the full read sequence\\n  and quality. This wil","l occur if the alignment is part of a chimeric alignment,\\n  or if the read was trimmed. When this occurs, the CIGAR for this read will\\n  begin/end with a hard clip operator that will indicate the length of the excised sequence.\",\"default\":null},{\"name\":\"alignedQuality\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"The quality of the read sequence contained in this alignment record.\\n  `alignedSequence` and `alignedQuality` may be shorter than the full read sequence\\n  and quality. This will occur if the alignment is part of a chimeric alignment,\\n  or if the read was trimmed. When this occurs, the CIGAR for this read will\\n  begin/end with a hard clip operator that will indicate the length of the excised sequence.\",\"default\":[]},{\"name\":\"nextMatePosition\",\"type\":[\"null\",\"GAPosition\"],\"doc\":\"The mapping of the primary alignment of the `(readNumber+1)%numberReads`\\n  read in the fragment. It replaces mate position and mate strand in SAM.\",\"default\":null},{\"name\":\"info\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"array\",\"items\":\"string\"}},\"doc\":\"A map of additional read alignment information.\",\"default\":{}}]}");
  public static org.apache.avro.Schema getClassSchema() { return SCHEMA$; }
  /** The read alignment ID. This ID is unique within the read group this
  alignment belongs to. This field may not be provided by all backends.
  Its intended use is to make caching and UI display easier for
  genome browsers and other light weight clients. */
  @Deprecated public java.lang.CharSequence id;
  /** The ID of the read group this read belongs to.
  (Every read must belong to exactly one read group.) */
  @Deprecated public java.lang.CharSequence readGroupId;
  /** The fragment name. Equivalent to QNAME (query template name) in SAM. */
  @Deprecated public java.lang.CharSequence fragmentName;
  /** The orientation and the distance between reads from the fragment are
  consistent with the sequencing protocol (extension to SAM flag 0x2) */
  @Deprecated public java.lang.Boolean properPlacement;
  /** The fragment is a PCR or optical duplicate (SAM flag 0x400) */
  @Deprecated public java.lang.Boolean duplicateFragment;
  /** The number of reads in the fragment (extension to SAM flag 0x1) */
  @Deprecated public java.lang.Integer numberReads;
  /** The observed length of the fragment, equivalent to TLEN in SAM. */
  @Deprecated public java.lang.Integer fragmentLength;
  /** The read number in sequencing. 0-based and less than numberReads. This field
  replaces SAM flag 0x40 and 0x80. */
  @Deprecated public java.lang.Integer readNumber;
  /** SAM flag 0x200 */
  @Deprecated public java.lang.Boolean failedVendorQualityChecks;
  /** The linear alignment for this alignment record. This field will be
  null if the read is unmapped. */
  @Deprecated public org.ga4gh.GALinearAlignment alignment;
  /** Whether this alignment is secondary. Equivalent to SAM flag 0x100.
  A secondary alignment represents an alternative to the primary alignment
  for this read. Aligners may return secondary alignments if a read can map
  ambiguously to multiple coordinates in the genome.

  By convention, each read has one and only one alignment where both
  secondaryAlignment and supplementaryAlignment are false. */
  @Deprecated public java.lang.Boolean secondaryAlignment;
  /** Whether this alignment is supplementary. Equivalent to SAM flag 0x800.
  Supplementary alignments are used in the representation of a chimeric
  alignment. In a chimeric alignment, a read is split into multiple
  linear alignments that map to different reference contigs. The first
  linear alignment in the read will be designated as the representative alignment;
  the remaining linear alignments will be designated as supplementary alignments.
  These alignments may have different mapping quality scores.

  In each linear alignment in a chimeric alignment, the read will be hard clipped.
  The `alignedSequence` and `alignedQuality` fields in the alignment record will
  only represent the bases for its respective linear alignment. */
  @Deprecated public java.lang.Boolean supplementaryAlignment;
  /** The bases of the read sequence contained in this alignment record.
  `alignedSequence` and `alignedQuality` may be shorter than the full read sequence
  and quality. This will occur if the alignment is part of a chimeric alignment,
  or if the read was trimmed. When this occurs, the CIGAR for this read will
  begin/end with a hard clip operator that will indicate the length of the excised sequence. */
  @Deprecated public java.lang.CharSequence alignedSequence;
  /** The quality of the read sequence contained in this alignment record.
  `alignedSequence` and `alignedQuality` may be shorter than the full read sequence
  and quality. This will occur if the alignment is part of a chimeric alignment,
  or if the read was trimmed. When this occurs, the CIGAR for this read will
  begin/end with a hard clip operator that will indicate the length of the excised sequence. */
  @Deprecated public java.util.List<java.lang.Integer> alignedQuality;
  /** The mapping of the primary alignment of the `(readNumber+1)%numberReads`
  read in the fragment. It replaces mate position and mate strand in SAM. */
  @Deprecated public org.ga4gh.GAPosition nextMatePosition;
  /** A map of additional read alignment information. */
  @Deprecated public java.util.Map<java.lang.CharSequence,java.util.List<java.lang.CharSequence>> info;

  /**
   * Default constructor.  Note that this does not initialize fields
   * to their default values from the schema.  If that is desired then
   * one should use <code>newBuilder()</code>. 
   */
  public GAReadAlignment() {}

  /**
   * All-args constructor.
   */
  public GAReadAlignment(java.lang.CharSequence id, java.lang.CharSequence readGroupId, java.lang.CharSequence fragmentName, java.lang.Boolean properPlacement, java.lang.Boolean duplicateFragment, java.lang.Integer numberReads, java.lang.Integer fragmentLength, java.lang.Integer readNumber, java.lang.Boolean failedVendorQualityChecks, org.ga4gh.GALinearAlignment alignment, java.lang.Boolean secondaryAlignment, java.lang.Boolean supplementaryAlignment, java.lang.CharSequence alignedSequence, java.util.List<java.lang.Integer> alignedQuality, org.ga4gh.GAPosition nextMatePosition, java.util.Map<java.lang.CharSequence,java.util.List<java.lang.CharSequence>> info) {
    this.id = id;
    this.readGroupId = readGroupId;
    this.fragmentName = fragmentName;
    this.properPlacement = properPlacement;
    this.duplicateFragment = duplicateFragment;
    this.numberReads = numberReads;
    this.fragmentLength = fragmentLength;
    this.readNumber = readNumber;
    this.failedVendorQualityChecks = failedVendorQualityChecks;
    this.alignment = alignment;
    this.secondaryAlignment = secondaryAlignment;
    this.supplementaryAlignment = supplementaryAlignment;
    this.alignedSequence = alignedSequence;
    this.alignedQuality = alignedQuality;
    this.nextMatePosition = nextMatePosition;
    this.info = info;
  }

  public org.apache.avro.Schema getSchema() { return SCHEMA$; }
  // Used by DatumWriter.  Applications should not call. 
  public java.lang.Object get(int field$) {
    switch (field$) {
    case 0: return id;
    case 1: return readGroupId;
    case 2: return fragmentName;
    case 3: return properPlacement;
    case 4: return duplicateFragment;
    case 5: return numberReads;
    case 6: return fragmentLength;
    case 7: return readNumber;
    case 8: return failedVendorQualityChecks;
    case 9: return alignment;
    case 10: return secondaryAlignment;
    case 11: return supplementaryAlignment;
    case 12: return alignedSequence;
    case 13: return alignedQuality;
    case 14: return nextMatePosition;
    case 15: return info;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }
  // Used by DatumReader.  Applications should not call. 
  @SuppressWarnings(value="unchecked")
  public void put(int field$, java.lang.Object value$) {
    switch (field$) {
    case 0: id = (java.lang.CharSequence)value$; break;
    case 1: readGroupId = (java.lang.CharSequence)value$; break;
    case 2: fragmentName = (java.lang.CharSequence)value$; break;
    case 3: properPlacement = (java.lang.Boolean)value$; break;
    case 4: duplicateFragment = (java.lang.Boolean)value$; break;
    case 5: numberReads = (java.lang.Integer)value$; break;
    case 6: fragmentLength = (java.lang.Integer)value$; break;
    case 7: readNumber = (java.lang.Integer)value$; break;
    case 8: failedVendorQualityChecks = (java.lang.Boolean)value$; break;
    case 9: alignment = (org.ga4gh.GALinearAlignment)value$; break;
    case 10: secondaryAlignment = (java.lang.Boolean)value$; break;
    case 11: supplementaryAlignment = (java.lang.Boolean)value$; break;
    case 12: alignedSequence = (java.lang.CharSequence)value$; break;
    case 13: alignedQuality = (java.util.List<java.lang.Integer>)value$; break;
    case 14: nextMatePosition = (org.ga4gh.GAPosition)value$; break;
    case 15: info = (java.util.Map<java.lang.CharSequence,java.util.List<java.lang.CharSequence>>)value$; break;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }

  /**
   * Gets the value of the 'id' field.
   * The read alignment ID. This ID is unique within the read group this
  alignment belongs to. This field may not be provided by all backends.
  Its intended use is to make caching and UI display easier for
  genome browsers and other light weight clients.   */
  public java.lang.CharSequence getId() {
    return id;
  }

  /**
   * Sets the value of the 'id' field.
   * The read alignment ID. This ID is unique within the read group this
  alignment belongs to. This field may not be provided by all backends.
  Its intended use is to make caching and UI display easier for
  genome browsers and other light weight clients.   * @param value the value to set.
   */
  public void setId(java.lang.CharSequence value) {
    this.id = value;
  }

  /**
   * Gets the value of the 'readGroupId' field.
   * The ID of the read group this read belongs to.
  (Every read must belong to exactly one read group.)   */
  public java.lang.CharSequence getReadGroupId() {
    return readGroupId;
  }

  /**
   * Sets the value of the 'readGroupId' field.
   * The ID of the read group this read belongs to.
  (Every read must belong to exactly one read group.)   * @param value the value to set.
   */
  public void setReadGroupId(java.lang.CharSequence value) {
    this.readGroupId = value;
  }

  /**
   * Gets the value of the 'fragmentName' field.
   * The fragment name. Equivalent to QNAME (query template name) in SAM.   */
  public java.lang.CharSequence getFragmentName() {
    return fragmentName;
  }

  /**
   * Sets the value of the 'fragmentName' field.
   * The fragment name. Equivalent to QNAME (query template name) in SAM.   * @param value the value to set.
   */
  public void setFragmentName(java.lang.CharSequence value) {
    this.fragmentName = value;
  }

  /**
   * Gets the value of the 'properPlacement' field.
   * The orientation and the distance between reads from the fragment are
  consistent with the sequencing protocol (extension to SAM flag 0x2)   */
  public java.lang.Boolean getProperPlacement() {
    return properPlacement;
  }

  /**
   * Sets the value of the 'properPlacement' field.
   * The orientation and the distance between reads from the fragment are
  consistent with the sequencing protocol (extension to SAM flag 0x2)   * @param value the value to set.
   */
  public void setProperPlacement(java.lang.Boolean value) {
    this.properPlacement = value;
  }

  /**
   * Gets the value of the 'duplicateFragment' field.
   * The fragment is a PCR or optical duplicate (SAM flag 0x400)   */
  public java.lang.Boolean getDuplicateFragment() {
    return duplicateFragment;
  }

  /**
   * Sets the value of the 'duplicateFragment' field.
   * The fragment is a PCR or optical duplicate (SAM flag 0x400)   * @param value the value to set.
   */
  public void setDuplicateFragment(java.lang.Boolean value) {
    this.duplicateFragment = value;
  }

  /**
   * Gets the value of the 'numberReads' field.
   * The number of reads in the fragment (extension to SAM flag 0x1)   */
  public java.lang.Integer getNumberReads() {
    return numberReads;
  }

  /**
   * Sets the value of the 'numberReads' field.
   * The number of reads in the fragment (extension to SAM flag 0x1)   * @param value the value to set.
   */
  public void setNumberReads(java.lang.Integer value) {
    this.numberReads = value;
  }

  /**
   * Gets the value of the 'fragmentLength' field.
   * The observed length of the fragment, equivalent to TLEN in SAM.   */
  public java.lang.Integer getFragmentLength() {
    return fragmentLength;
  }

  /**
   * Sets the value of the 'fragmentLength' field.
   * The observed length of the fragment, equivalent to TLEN in SAM.   * @param value the value to set.
   */
  public void setFragmentLength(java.lang.Integer value) {
    this.fragmentLength = value;
  }

  /**
   * Gets the value of the 'readNumber' field.
   * The read number in sequencing. 0-based and less than numberReads. This field
  replaces SAM flag 0x40 and 0x80.   */
  public java.lang.Integer getReadNumber() {
    return readNumber;
  }

  /**
   * Sets the value of the 'readNumber' field.
   * The read number in sequencing. 0-based and less than numberReads. This field
  replaces SAM flag 0x40 and 0x80.   * @param value the value to set.
   */
  public void setReadNumber(java.lang.Integer value) {
    this.readNumber = value;
  }

  /**
   * Gets the value of the 'failedVendorQualityChecks' field.
   * SAM flag 0x200   */
  public java.lang.Boolean getFailedVendorQualityChecks() {
    return failedVendorQualityChecks;
  }

  /**
   * Sets the value of the 'failedVendorQualityChecks' field.
   * SAM flag 0x200   * @param value the value to set.
   */
  public void setFailedVendorQualityChecks(java.lang.Boolean value) {
    this.failedVendorQualityChecks = value;
  }

  /**
   * Gets the value of the 'alignment' field.
   * The linear alignment for this alignment record. This field will be
  null if the read is unmapped.   */
  public org.ga4gh.GALinearAlignment getAlignment() {
    return alignment;
  }

  /**
   * Sets the value of the 'alignment' field.
   * The linear alignment for this alignment record. This field will be
  null if the read is unmapped.   * @param value the value to set.
   */
  public void setAlignment(org.ga4gh.GALinearAlignment value) {
    this.alignment = value;
  }

  /**
   * Gets the value of the 'secondaryAlignment' field.
   * Whether this alignment is secondary. Equivalent to SAM flag 0x100.
  A secondary alignment represents an alternative to the primary alignment
  for this read. Aligners may return secondary alignments if a read can map
  ambiguously to multiple coordinates in the genome.

  By convention, each read has one and only one alignment where both
  secondaryAlignment and supplementaryAlignment are false.   */
  public java.lang.Boolean getSecondaryAlignment() {
    return secondaryAlignment;
  }

  /**
   * Sets the value of the 'secondaryAlignment' field.
   * Whether this alignment is secondary. Equivalent to SAM flag 0x100.
  A secondary alignment represents an alternative to the primary alignment
  for this read. Aligners may return secondary alignments if a read can map
  ambiguously to multiple coordinates in the genome.

  By convention, each read has one and only one alignment where both
  secondaryAlignment and supplementaryAlignment are false.   * @param value the value to set.
   */
  public void setSecondaryAlignment(java.lang.Boolean value) {
    this.secondaryAlignment = value;
  }

  /**
   * Gets the value of the 'supplementaryAlignment' field.
   * Whether this alignment is supplementary. Equivalent to SAM flag 0x800.
  Supplementary alignments are used in the representation of a chimeric
  alignment. In a chimeric alignment, a read is split into multiple
  linear alignments that map to different reference contigs. The first
  linear alignment in the read will be designated as the representative alignment;
  the remaining linear alignments will be designated as supplementary alignments.
  These alignments may have different mapping quality scores.

  In each linear alignment in a chimeric alignment, the read will be hard clipped.
  The `alignedSequence` and `alignedQuality` fields in the alignment record will
  only represent the bases for its respective linear alignment.   */
  public java.lang.Boolean getSupplementaryAlignment() {
    return supplementaryAlignment;
  }

  /**
   * Sets the value of the 'supplementaryAlignment' field.
   * Whether this alignment is supplementary. Equivalent to SAM flag 0x800.
  Supplementary alignments are used in the representation of a chimeric
  alignment. In a chimeric alignment, a read is split into multiple
  linear alignments that map to different reference contigs. The first
  linear alignment in the read will be designated as the representative alignment;
  the remaining linear alignments will be designated as supplementary alignments.
  These alignments may have different mapping quality scores.

  In each linear alignment in a chimeric alignment, the read will be hard clipped.
  The `alignedSequence` and `alignedQuality` fields in the alignment record will
  only represent the bases for its respective linear alignment.   * @param value the value to set.
   */
  public void setSupplementaryAlignment(java.lang.Boolean value) {
    this.supplementaryAlignment = value;
  }

  /**
   * Gets the value of the 'alignedSequence' field.
   * The bases of the read sequence contained in this alignment record.
  `alignedSequence` and `alignedQuality` may be shorter than the full read sequence
  and quality. This will occur if the alignment is part of a chimeric alignment,
  or if the read was trimmed. When this occurs, the CIGAR for this read will
  begin/end with a hard clip operator that will indicate the length of the excised sequence.   */
  public java.lang.CharSequence getAlignedSequence() {
    return alignedSequence;
  }

  /**
   * Sets the value of the 'alignedSequence' field.
   * The bases of the read sequence contained in this alignment record.
  `alignedSequence` and `alignedQuality` may be shorter than the full read sequence
  and quality. This will occur if the alignment is part of a chimeric alignment,
  or if the read was trimmed. When this occurs, the CIGAR for this read will
  begin/end with a hard clip operator that will indicate the length of the excised sequence.   * @param value the value to set.
   */
  public void setAlignedSequence(java.lang.CharSequence value) {
    this.alignedSequence = value;
  }

  /**
   * Gets the value of the 'alignedQuality' field.
   * The quality of the read sequence contained in this alignment record.
  `alignedSequence` and `alignedQuality` may be shorter than the full read sequence
  and quality. This will occur if the alignment is part of a chimeric alignment,
  or if the read was trimmed. When this occurs, the CIGAR for this read will
  begin/end with a hard clip operator that will indicate the length of the excised sequence.   */
  public java.util.List<java.lang.Integer> getAlignedQuality() {
    return alignedQuality;
  }

  /**
   * Sets the value of the 'alignedQuality' field.
   * The quality of the read sequence contained in this alignment record.
  `alignedSequence` and `alignedQuality` may be shorter than the full read sequence
  and quality. This will occur if the alignment is part of a chimeric alignment,
  or if the read was trimmed. When this occurs, the CIGAR for this read will
  begin/end with a hard clip operator that will indicate the length of the excised sequence.   * @param value the value to set.
   */
  public void setAlignedQuality(java.util.List<java.lang.Integer> value) {
    this.alignedQuality = value;
  }

  /**
   * Gets the value of the 'nextMatePosition' field.
   * The mapping of the primary alignment of the `(readNumber+1)%numberReads`
  read in the fragment. It replaces mate position and mate strand in SAM.   */
  public org.ga4gh.GAPosition getNextMatePosition() {
    return nextMatePosition;
  }

  /**
   * Sets the value of the 'nextMatePosition' field.
   * The mapping of the primary alignment of the `(readNumber+1)%numberReads`
  read in the fragment. It replaces mate position and mate strand in SAM.   * @param value the value to set.
   */
  public void setNextMatePosition(org.ga4gh.GAPosition value) {
    this.nextMatePosition = value;
  }

  /**
   * Gets the value of the 'info' field.
   * A map of additional read alignment information.   */
  public java.util.Map<java.lang.CharSequence,java.util.List<java.lang.CharSequence>> getInfo() {
    return info;
  }

  /**
   * Sets the value of the 'info' field.
   * A map of additional read alignment information.   * @param value the value to set.
   */
  public void setInfo(java.util.Map<java.lang.CharSequence,java.util.List<java.lang.CharSequence>> value) {
    this.info = value;
  }

  /** Creates a new GAReadAlignment RecordBuilder */
  public static org.ga4gh.GAReadAlignment.Builder newBuilder() {
    return new org.ga4gh.GAReadAlignment.Builder();
  }
  
  /** Creates a new GAReadAlignment RecordBuilder by copying an existing Builder */
  public static org.ga4gh.GAReadAlignment.Builder newBuilder(org.ga4gh.GAReadAlignment.Builder other) {
    return new org.ga4gh.GAReadAlignment.Builder(other);
  }
  
  /** Creates a new GAReadAlignment RecordBuilder by copying an existing GAReadAlignment instance */
  public static org.ga4gh.GAReadAlignment.Builder newBuilder(org.ga4gh.GAReadAlignment other) {
    return new org.ga4gh.GAReadAlignment.Builder(other);
  }
  
  /**
   * RecordBuilder for GAReadAlignment instances.
   */
  public static class Builder extends org.apache.avro.specific.SpecificRecordBuilderBase<GAReadAlignment>
    implements org.apache.avro.data.RecordBuilder<GAReadAlignment> {

    private java.lang.CharSequence id;
    private java.lang.CharSequence readGroupId;
    private java.lang.CharSequence fragmentName;
    private java.lang.Boolean properPlacement;
    private java.lang.Boolean duplicateFragment;
    private java.lang.Integer numberReads;
    private java.lang.Integer fragmentLength;
    private java.lang.Integer readNumber;
    private java.lang.Boolean failedVendorQualityChecks;
    private org.ga4gh.GALinearAlignment alignment;
    private java.lang.Boolean secondaryAlignment;
    private java.lang.Boolean supplementaryAlignment;
    private java.lang.CharSequence alignedSequence;
    private java.util.List<java.lang.Integer> alignedQuality;
    private org.ga4gh.GAPosition nextMatePosition;
    private java.util.Map<java.lang.CharSequence,java.util.List<java.lang.CharSequence>> info;

    /** Creates a new Builder */
    private Builder() {
      super(org.ga4gh.GAReadAlignment.SCHEMA$);
    }
    
    /** Creates a Builder by copying an existing Builder */
    private Builder(org.ga4gh.GAReadAlignment.Builder other) {
      super(other);
      if (isValidValue(fields()[0], other.id)) {
        this.id = data().deepCopy(fields()[0].schema(), other.id);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.readGroupId)) {
        this.readGroupId = data().deepCopy(fields()[1].schema(), other.readGroupId);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.fragmentName)) {
        this.fragmentName = data().deepCopy(fields()[2].schema(), other.fragmentName);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.properPlacement)) {
        this.properPlacement = data().deepCopy(fields()[3].schema(), other.properPlacement);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.duplicateFragment)) {
        this.duplicateFragment = data().deepCopy(fields()[4].schema(), other.duplicateFragment);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.numberReads)) {
        this.numberReads = data().deepCopy(fields()[5].schema(), other.numberReads);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.fragmentLength)) {
        this.fragmentLength = data().deepCopy(fields()[6].schema(), other.fragmentLength);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.readNumber)) {
        this.readNumber = data().deepCopy(fields()[7].schema(), other.readNumber);
        fieldSetFlags()[7] = true;
      }
      if (isValidValue(fields()[8], other.failedVendorQualityChecks)) {
        this.failedVendorQualityChecks = data().deepCopy(fields()[8].schema(), other.failedVendorQualityChecks);
        fieldSetFlags()[8] = true;
      }
      if (isValidValue(fields()[9], other.alignment)) {
        this.alignment = data().deepCopy(fields()[9].schema(), other.alignment);
        fieldSetFlags()[9] = true;
      }
      if (isValidValue(fields()[10], other.secondaryAlignment)) {
        this.secondaryAlignment = data().deepCopy(fields()[10].schema(), other.secondaryAlignment);
        fieldSetFlags()[10] = true;
      }
      if (isValidValue(fields()[11], other.supplementaryAlignment)) {
        this.supplementaryAlignment = data().deepCopy(fields()[11].schema(), other.supplementaryAlignment);
        fieldSetFlags()[11] = true;
      }
      if (isValidValue(fields()[12], other.alignedSequence)) {
        this.alignedSequence = data().deepCopy(fields()[12].schema(), other.alignedSequence);
        fieldSetFlags()[12] = true;
      }
      if (isValidValue(fields()[13], other.alignedQuality)) {
        this.alignedQuality = data().deepCopy(fields()[13].schema(), other.alignedQuality);
        fieldSetFlags()[13] = true;
      }
      if (isValidValue(fields()[14], other.nextMatePosition)) {
        this.nextMatePosition = data().deepCopy(fields()[14].schema(), other.nextMatePosition);
        fieldSetFlags()[14] = true;
      }
      if (isValidValue(fields()[15], other.info)) {
        this.info = data().deepCopy(fields()[15].schema(), other.info);
        fieldSetFlags()[15] = true;
      }
    }
    
    /** Creates a Builder by copying an existing GAReadAlignment instance */
    private Builder(org.ga4gh.GAReadAlignment other) {
            super(org.ga4gh.GAReadAlignment.SCHEMA$);
      if (isValidValue(fields()[0], other.id)) {
        this.id = data().deepCopy(fields()[0].schema(), other.id);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.readGroupId)) {
        this.readGroupId = data().deepCopy(fields()[1].schema(), other.readGroupId);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.fragmentName)) {
        this.fragmentName = data().deepCopy(fields()[2].schema(), other.fragmentName);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.properPlacement)) {
        this.properPlacement = data().deepCopy(fields()[3].schema(), other.properPlacement);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.duplicateFragment)) {
        this.duplicateFragment = data().deepCopy(fields()[4].schema(), other.duplicateFragment);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.numberReads)) {
        this.numberReads = data().deepCopy(fields()[5].schema(), other.numberReads);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.fragmentLength)) {
        this.fragmentLength = data().deepCopy(fields()[6].schema(), other.fragmentLength);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.readNumber)) {
        this.readNumber = data().deepCopy(fields()[7].schema(), other.readNumber);
        fieldSetFlags()[7] = true;
      }
      if (isValidValue(fields()[8], other.failedVendorQualityChecks)) {
        this.failedVendorQualityChecks = data().deepCopy(fields()[8].schema(), other.failedVendorQualityChecks);
        fieldSetFlags()[8] = true;
      }
      if (isValidValue(fields()[9], other.alignment)) {
        this.alignment = data().deepCopy(fields()[9].schema(), other.alignment);
        fieldSetFlags()[9] = true;
      }
      if (isValidValue(fields()[10], other.secondaryAlignment)) {
        this.secondaryAlignment = data().deepCopy(fields()[10].schema(), other.secondaryAlignment);
        fieldSetFlags()[10] = true;
      }
      if (isValidValue(fields()[11], other.supplementaryAlignment)) {
        this.supplementaryAlignment = data().deepCopy(fields()[11].schema(), other.supplementaryAlignment);
        fieldSetFlags()[11] = true;
      }
      if (isValidValue(fields()[12], other.alignedSequence)) {
        this.alignedSequence = data().deepCopy(fields()[12].schema(), other.alignedSequence);
        fieldSetFlags()[12] = true;
      }
      if (isValidValue(fields()[13], other.alignedQuality)) {
        this.alignedQuality = data().deepCopy(fields()[13].schema(), other.alignedQuality);
        fieldSetFlags()[13] = true;
      }
      if (isValidValue(fields()[14], other.nextMatePosition)) {
        this.nextMatePosition = data().deepCopy(fields()[14].schema(), other.nextMatePosition);
        fieldSetFlags()[14] = true;
      }
      if (isValidValue(fields()[15], other.info)) {
        this.info = data().deepCopy(fields()[15].schema(), other.info);
        fieldSetFlags()[15] = true;
      }
    }

    /** Gets the value of the 'id' field */
    public java.lang.CharSequence getId() {
      return id;
    }
    
    /** Sets the value of the 'id' field */
    public org.ga4gh.GAReadAlignment.Builder setId(java.lang.CharSequence value) {
      validate(fields()[0], value);
      this.id = value;
      fieldSetFlags()[0] = true;
      return this; 
    }
    
    /** Checks whether the 'id' field has been set */
    public boolean hasId() {
      return fieldSetFlags()[0];
    }
    
    /** Clears the value of the 'id' field */
    public org.ga4gh.GAReadAlignment.Builder clearId() {
      id = null;
      fieldSetFlags()[0] = false;
      return this;
    }

    /** Gets the value of the 'readGroupId' field */
    public java.lang.CharSequence getReadGroupId() {
      return readGroupId;
    }
    
    /** Sets the value of the 'readGroupId' field */
    public org.ga4gh.GAReadAlignment.Builder setReadGroupId(java.lang.CharSequence value) {
      validate(fields()[1], value);
      this.readGroupId = value;
      fieldSetFlags()[1] = true;
      return this; 
    }
    
    /** Checks whether the 'readGroupId' field has been set */
    public boolean hasReadGroupId() {
      return fieldSetFlags()[1];
    }
    
    /** Clears the value of the 'readGroupId' field */
    public org.ga4gh.GAReadAlignment.Builder clearReadGroupId() {
      readGroupId = null;
      fieldSetFlags()[1] = false;
      return this;
    }

    /** Gets the value of the 'fragmentName' field */
    public java.lang.CharSequence getFragmentName() {
      return fragmentName;
    }
    
    /** Sets the value of the 'fragmentName' field */
    public org.ga4gh.GAReadAlignment.Builder setFragmentName(java.lang.CharSequence value) {
      validate(fields()[2], value);
      this.fragmentName = value;
      fieldSetFlags()[2] = true;
      return this; 
    }
    
    /** Checks whether the 'fragmentName' field has been set */
    public boolean hasFragmentName() {
      return fieldSetFlags()[2];
    }
    
    /** Clears the value of the 'fragmentName' field */
    public org.ga4gh.GAReadAlignment.Builder clearFragmentName() {
      fragmentName = null;
      fieldSetFlags()[2] = false;
      return this;
    }

    /** Gets the value of the 'properPlacement' field */
    public java.lang.Boolean getProperPlacement() {
      return properPlacement;
    }
    
    /** Sets the value of the 'properPlacement' field */
    public org.ga4gh.GAReadAlignment.Builder setProperPlacement(java.lang.Boolean value) {
      validate(fields()[3], value);
      this.properPlacement = value;
      fieldSetFlags()[3] = true;
      return this; 
    }
    
    /** Checks whether the 'properPlacement' field has been set */
    public boolean hasProperPlacement() {
      return fieldSetFlags()[3];
    }
    
    /** Clears the value of the 'properPlacement' field */
    public org.ga4gh.GAReadAlignment.Builder clearProperPlacement() {
      properPlacement = null;
      fieldSetFlags()[3] = false;
      return this;
    }

    /** Gets the value of the 'duplicateFragment' field */
    public java.lang.Boolean getDuplicateFragment() {
      return duplicateFragment;
    }
    
    /** Sets the value of the 'duplicateFragment' field */
    public org.ga4gh.GAReadAlignment.Builder setDuplicateFragment(java.lang.Boolean value) {
      validate(fields()[4], value);
      this.duplicateFragment = value;
      fieldSetFlags()[4] = true;
      return this; 
    }
    
    /** Checks whether the 'duplicateFragment' field has been set */
    public boolean hasDuplicateFragment() {
      return fieldSetFlags()[4];
    }
    
    /** Clears the value of the 'duplicateFragment' field */
    public org.ga4gh.GAReadAlignment.Builder clearDuplicateFragment() {
      duplicateFragment = null;
      fieldSetFlags()[4] = false;
      return this;
    }

    /** Gets the value of the 'numberReads' field */
    public java.lang.Integer getNumberReads() {
      return numberReads;
    }
    
    /** Sets the value of the 'numberReads' field */
    public org.ga4gh.GAReadAlignment.Builder setNumberReads(java.lang.Integer value) {
      validate(fields()[5], value);
      this.numberReads = value;
      fieldSetFlags()[5] = true;
      return this; 
    }
    
    /** Checks whether the 'numberReads' field has been set */
    public boolean hasNumberReads() {
      return fieldSetFlags()[5];
    }
    
    /** Clears the value of the 'numberReads' field */
    public org.ga4gh.GAReadAlignment.Builder clearNumberReads() {
      numberReads = null;
      fieldSetFlags()[5] = false;
      return this;
    }

    /** Gets the value of the 'fragmentLength' field */
    public java.lang.Integer getFragmentLength() {
      return fragmentLength;
    }
    
    /** Sets the value of the 'fragmentLength' field */
    public org.ga4gh.GAReadAlignment.Builder setFragmentLength(java.lang.Integer value) {
      validate(fields()[6], value);
      this.fragmentLength = value;
      fieldSetFlags()[6] = true;
      return this; 
    }
    
    /** Checks whether the 'fragmentLength' field has been set */
    public boolean hasFragmentLength() {
      return fieldSetFlags()[6];
    }
    
    /** Clears the value of the 'fragmentLength' field */
    public org.ga4gh.GAReadAlignment.Builder clearFragmentLength() {
      fragmentLength = null;
      fieldSetFlags()[6] = false;
      return this;
    }

    /** Gets the value of the 'readNumber' field */
    public java.lang.Integer getReadNumber() {
      return readNumber;
    }
    
    /** Sets the value of the 'readNumber' field */
    public org.ga4gh.GAReadAlignment.Builder setReadNumber(java.lang.Integer value) {
      validate(fields()[7], value);
      this.readNumber = value;
      fieldSetFlags()[7] = true;
      return this; 
    }
    
    /** Checks whether the 'readNumber' field has been set */
    public boolean hasReadNumber() {
      return fieldSetFlags()[7];
    }
    
    /** Clears the value of the 'readNumber' field */
    public org.ga4gh.GAReadAlignment.Builder clearReadNumber() {
      readNumber = null;
      fieldSetFlags()[7] = false;
      return this;
    }

    /** Gets the value of the 'failedVendorQualityChecks' field */
    public java.lang.Boolean getFailedVendorQualityChecks() {
      return failedVendorQualityChecks;
    }
    
    /** Sets the value of the 'failedVendorQualityChecks' field */
    public org.ga4gh.GAReadAlignment.Builder setFailedVendorQualityChecks(java.lang.Boolean value) {
      validate(fields()[8], value);
      this.failedVendorQualityChecks = value;
      fieldSetFlags()[8] = true;
      return this; 
    }
    
    /** Checks whether the 'failedVendorQualityChecks' field has been set */
    public boolean hasFailedVendorQualityChecks() {
      return fieldSetFlags()[8];
    }
    
    /** Clears the value of the 'failedVendorQualityChecks' field */
    public org.ga4gh.GAReadAlignment.Builder clearFailedVendorQualityChecks() {
      failedVendorQualityChecks = null;
      fieldSetFlags()[8] = false;
      return this;
    }

    /** Gets the value of the 'alignment' field */
    public org.ga4gh.GALinearAlignment getAlignment() {
      return alignment;
    }
    
    /** Sets the value of the 'alignment' field */
    public org.ga4gh.GAReadAlignment.Builder setAlignment(org.ga4gh.GALinearAlignment value) {
      validate(fields()[9], value);
      this.alignment = value;
      fieldSetFlags()[9] = true;
      return this; 
    }
    
    /** Checks whether the 'alignment' field has been set */
    public boolean hasAlignment() {
      return fieldSetFlags()[9];
    }
    
    /** Clears the value of the 'alignment' field */
    public org.ga4gh.GAReadAlignment.Builder clearAlignment() {
      alignment = null;
      fieldSetFlags()[9] = false;
      return this;
    }

    /** Gets the value of the 'secondaryAlignment' field */
    public java.lang.Boolean getSecondaryAlignment() {
      return secondaryAlignment;
    }
    
    /** Sets the value of the 'secondaryAlignment' field */
    public org.ga4gh.GAReadAlignment.Builder setSecondaryAlignment(java.lang.Boolean value) {
      validate(fields()[10], value);
      this.secondaryAlignment = value;
      fieldSetFlags()[10] = true;
      return this; 
    }
    
    /** Checks whether the 'secondaryAlignment' field has been set */
    public boolean hasSecondaryAlignment() {
      return fieldSetFlags()[10];
    }
    
    /** Clears the value of the 'secondaryAlignment' field */
    public org.ga4gh.GAReadAlignment.Builder clearSecondaryAlignment() {
      secondaryAlignment = null;
      fieldSetFlags()[10] = false;
      return this;
    }

    /** Gets the value of the 'supplementaryAlignment' field */
    public java.lang.Boolean getSupplementaryAlignment() {
      return supplementaryAlignment;
    }
    
    /** Sets the value of the 'supplementaryAlignment' field */
    public org.ga4gh.GAReadAlignment.Builder setSupplementaryAlignment(java.lang.Boolean value) {
      validate(fields()[11], value);
      this.supplementaryAlignment = value;
      fieldSetFlags()[11] = true;
      return this; 
    }
    
    /** Checks whether the 'supplementaryAlignment' field has been set */
    public boolean hasSupplementaryAlignment() {
      return fieldSetFlags()[11];
    }
    
    /** Clears the value of the 'supplementaryAlignment' field */
    public org.ga4gh.GAReadAlignment.Builder clearSupplementaryAlignment() {
      supplementaryAlignment = null;
      fieldSetFlags()[11] = false;
      return this;
    }

    /** Gets the value of the 'alignedSequence' field */
    public java.lang.CharSequence getAlignedSequence() {
      return alignedSequence;
    }
    
    /** Sets the value of the 'alignedSequence' field */
    public org.ga4gh.GAReadAlignment.Builder setAlignedSequence(java.lang.CharSequence value) {
      validate(fields()[12], value);
      this.alignedSequence = value;
      fieldSetFlags()[12] = true;
      return this; 
    }
    
    /** Checks whether the 'alignedSequence' field has been set */
    public boolean hasAlignedSequence() {
      return fieldSetFlags()[12];
    }
    
    /** Clears the value of the 'alignedSequence' field */
    public org.ga4gh.GAReadAlignment.Builder clearAlignedSequence() {
      alignedSequence = null;
      fieldSetFlags()[12] = false;
      return this;
    }

    /** Gets the value of the 'alignedQuality' field */
    public java.util.List<java.lang.Integer> getAlignedQuality() {
      return alignedQuality;
    }
    
    /** Sets the value of the 'alignedQuality' field */
    public org.ga4gh.GAReadAlignment.Builder setAlignedQuality(java.util.List<java.lang.Integer> value) {
      validate(fields()[13], value);
      this.alignedQuality = value;
      fieldSetFlags()[13] = true;
      return this; 
    }
    
    /** Checks whether the 'alignedQuality' field has been set */
    public boolean hasAlignedQuality() {
      return fieldSetFlags()[13];
    }
    
    /** Clears the value of the 'alignedQuality' field */
    public org.ga4gh.GAReadAlignment.Builder clearAlignedQuality() {
      alignedQuality = null;
      fieldSetFlags()[13] = false;
      return this;
    }

    /** Gets the value of the 'nextMatePosition' field */
    public org.ga4gh.GAPosition getNextMatePosition() {
      return nextMatePosition;
    }
    
    /** Sets the value of the 'nextMatePosition' field */
    public org.ga4gh.GAReadAlignment.Builder setNextMatePosition(org.ga4gh.GAPosition value) {
      validate(fields()[14], value);
      this.nextMatePosition = value;
      fieldSetFlags()[14] = true;
      return this; 
    }
    
    /** Checks whether the 'nextMatePosition' field has been set */
    public boolean hasNextMatePosition() {
      return fieldSetFlags()[14];
    }
    
    /** Clears the value of the 'nextMatePosition' field */
    public org.ga4gh.GAReadAlignment.Builder clearNextMatePosition() {
      nextMatePosition = null;
      fieldSetFlags()[14] = false;
      return this;
    }

    /** Gets the value of the 'info' field */
    public java.util.Map<java.lang.CharSequence,java.util.List<java.lang.CharSequence>> getInfo() {
      return info;
    }
    
    /** Sets the value of the 'info' field */
    public org.ga4gh.GAReadAlignment.Builder setInfo(java.util.Map<java.lang.CharSequence,java.util.List<java.lang.CharSequence>> value) {
      validate(fields()[15], value);
      this.info = value;
      fieldSetFlags()[15] = true;
      return this; 
    }
    
    /** Checks whether the 'info' field has been set */
    public boolean hasInfo() {
      return fieldSetFlags()[15];
    }
    
    /** Clears the value of the 'info' field */
    public org.ga4gh.GAReadAlignment.Builder clearInfo() {
      info = null;
      fieldSetFlags()[15] = false;
      return this;
    }

    @Override
    public GAReadAlignment build() {
      try {
        GAReadAlignment record = new GAReadAlignment();
        record.id = fieldSetFlags()[0] ? this.id : (java.lang.CharSequence) defaultValue(fields()[0]);
        record.readGroupId = fieldSetFlags()[1] ? this.readGroupId : (java.lang.CharSequence) defaultValue(fields()[1]);
        record.fragmentName = fieldSetFlags()[2] ? this.fragmentName : (java.lang.CharSequence) defaultValue(fields()[2]);
        record.properPlacement = fieldSetFlags()[3] ? this.properPlacement : (java.lang.Boolean) defaultValue(fields()[3]);
        record.duplicateFragment = fieldSetFlags()[4] ? this.duplicateFragment : (java.lang.Boolean) defaultValue(fields()[4]);
        record.numberReads = fieldSetFlags()[5] ? this.numberReads : (java.lang.Integer) defaultValue(fields()[5]);
        record.fragmentLength = fieldSetFlags()[6] ? this.fragmentLength : (java.lang.Integer) defaultValue(fields()[6]);
        record.readNumber = fieldSetFlags()[7] ? this.readNumber : (java.lang.Integer) defaultValue(fields()[7]);
        record.failedVendorQualityChecks = fieldSetFlags()[8] ? this.failedVendorQualityChecks : (java.lang.Boolean) defaultValue(fields()[8]);
        record.alignment = fieldSetFlags()[9] ? this.alignment : (org.ga4gh.GALinearAlignment) defaultValue(fields()[9]);
        record.secondaryAlignment = fieldSetFlags()[10] ? this.secondaryAlignment : (java.lang.Boolean) defaultValue(fields()[10]);
        record.supplementaryAlignment = fieldSetFlags()[11] ? this.supplementaryAlignment : (java.lang.Boolean) defaultValue(fields()[11]);
        record.alignedSequence = fieldSetFlags()[12] ? this.alignedSequence : (java.lang.CharSequence) defaultValue(fields()[12]);
        record.alignedQuality = fieldSetFlags()[13] ? this.alignedQuality : (java.util.List<java.lang.Integer>) defaultValue(fields()[13]);
        record.nextMatePosition = fieldSetFlags()[14] ? this.nextMatePosition : (org.ga4gh.GAPosition) defaultValue(fields()[14]);
        record.info = fieldSetFlags()[15] ? this.info : (java.util.Map<java.lang.CharSequence,java.util.List<java.lang.CharSequence>>) defaultValue(fields()[15]);
        return record;
      } catch (Exception e) {
        throw new org.apache.avro.AvroRuntimeException(e);
      }
    }
  }
}
